pub mod chain;
pub mod sequential;
use crate::prompt::clean_prompt;
use crate::{llm::LLMResponse, record::Record};

use anyhow::Result;
use serde::Serialize;
use std::collections::HashMap;

#[async_trait::async_trait(?Send)]
pub trait Chain {
    /// Execute an LLM chain.
    async fn execute(&mut self) -> Result<ChainResult>;

    /// Set the context of the LLMChain.
    fn load_context<T>(&mut self, context: &T)
    where
        T: Serialize,
    {
        let context = serde_json::to_value(context).unwrap_or(serde_json::Value::Null);
        if let serde_json::Value::Object(map) = context {
            map.into_iter().for_each(|(key, value)| {
                let value = value.as_str().unwrap_or("");
                self.context().insert(key, clean_prompt(value, true));
            });
        }
    }

    /// Save a record content to the context of an LLM Chain.
    fn load_record(&mut self, name: &str, record: Record) {
        if !self.context().contains_key(name) {
            self.context().insert(
                name.to_string(),
                clean_prompt(record.content.to_string().as_str(), true),
            );
        }
    }

    /// Get the context of the LLMChain.
    fn context(&mut self) -> &mut HashMap<String, String>;
}

#[derive(Debug)]
pub struct ChainResult {
    /// Name of the chain which generated the result.
    pub name: String,

    /// LLM response generated by the chain.
    llm_response: Option<LLMResponse>,
}

impl ChainResult {
    /// Create a new chain result.
    pub fn new(name: String) -> ChainResult {
        ChainResult {
            name,
            llm_response: None,
        }
    }

    /// Get the LLM response content generated by the chain.
    pub fn content(&self) -> String {
        self.llm_response.as_ref().unwrap_or(&LLMResponse::Empty).to_string()
    }

    /// Get the role of the LLM response generated by the chain.
    pub fn role(&self) -> String {
        self.llm_response.as_ref().unwrap_or(&LLMResponse::Empty).get_role()
    }

    /// Get the LLM response generated by the chain.
    pub fn with_llm_response(mut self, llm_response: LLMResponse) -> Self {
        self.llm_response = Some(llm_response);
        self
    }
}
